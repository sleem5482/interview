دليل المقابلات الشامل للواجهات الأمامية

هذا الدليل يحتوي على 25 سؤالاً أساسياً في الواجهات الأمامية، مرتبة من المفاهيم الأساسية إلى المتقدمة في كل قسم (HTML، CSS، Tailwind CSS، JavaScript، React).

1. قسم HTML (هيكل الويب)

Q1: ما هو Semantic HTML؟

الإجابة: استخدام وسوم HTML لدلالتها المعنوية وليس لمجرد العرض. الوسوم مثل &lt;article&gt; و &lt;section&gt; و &lt;nav&gt; تصف المحتوى الذي تحويه. يحسن هذا بشكل كبير إمكانية الوصول لقارئات الشاشة ويعزز SEO (تحسين محركات البحث).

Q2: الفرق بين &lt;div&gt; و &lt;span&gt;؟

الإجابة:

&lt;div&gt; هو عنصر Block-level. يبدأ في سطر جديد ويشغل العرض الكامل المتاح له.

&lt;span&gt; هو عنصر Inline. يقع ضمن تدفق النص ويشغل فقط المساحة التي يحتاجها محتواه.

Q3: ما هي فائدة إعلان &lt;!DOCTYPE html&gt;؟

الإجابة: هو إعلان (وليس وسماً) يخبر المتصفح بإصدار HTML المستخدم. يضمن عرض الصفحة في "standards mode" (وضع المعايير) وليس "quirks mode" (وضع الخوارق)، مما يمنع أخطاء العرض القديمة.

Q4: ما هي استخدامات وسوم Meta Tags؟

الإجابة: توفر بيانات وصفية (metadata) حول المستند، والتي لا تظهر للمستخدم. يشمل ذلك:

مجموعة الأحرف (charset).

إعدادات منفذ العرض (viewport) للأجهزة المحمولة.

الوصف والكلمات المفتاحية للصفحة لـ SEO.

Q5: كيف يمكنك تحسين إمكانية الوصول للصفحة (Accessibility)؟

الإجابة: يكون بتحقيق أربعة نقاط رئيسية:

استخدام Semantic HTML بشكل صحيح.

توفير نص وصفي (alt text) لجميع الصور.

التأكد من أن جميع العناصر التفاعلية قابلة للاستخدام عبر لوحة المفاتيح.

استخدام أدوار ARIA (Accessible Rich Internet Applications) عند الحاجة لإضافة سياق.

2. قسم CSS (تنسيق الويب)

الأسئلة مرتبة من الأساسي إلى المتقدم.

Q1: ما هو CSS Box Model؟

الإجابة: النموذج الذي يعتبر كل عنصر HTML كصندوق مستطيل. يتكون من أربعة أجزاء، من الداخل إلى الخارج: Content (المحتوى)، Padding (الحشو الداخلي)، Border (الحد)، و Margin (الهامش الخارجي).

Q2: ما هي فائدة box-sizing: border-box؟

الإجابة: يخبر المتصفح بتضمين كل من padding و border ضمن العرض والارتفاع الإجماليين للعنصر. وهذا يجعل حسابات التخطيط أكثر سهولة ويمنع التدفق غير المتوقع (over flow) مقارنة بالوضع الافتراضي content-box.

Q3: ما الفرق بين em و rem؟

الإجابة:

em (وحدة نسبية): تعتمد على حجم خط العنصر الأصل (Parent Element).

rem (وحدة الجذر): تعتمد على حجم خط العنصر الجذري (الـ &lt;html&gt; Root Element). توفر rem قياساً أكثر ثباتاً واتساقاً عبر التطبيق.

Q4: ما هي Pseudo-elements؟

الإجابة: كلمة مفتاحية تُضاف إلى محدد لتنسيق جزء معين من عنصر لا يتم تمثيله بواسطة وسوم HTML أخرى. من الأمثلة الشائعة: ::before، ::after، ::first-line، و ::selection.

Q5: Flexbox مقابل Grid؟

الإجابة:

Flexbox: للتخطيطات ذات البعد الواحد (صف واحد أو عمود واحد). وهو مثالي لمحاذاة العناصر أو توزيع المسافة.

Grid: للتخطيطات ذات البعدين (صفوف وأعمدة في وقت واحد). وهو مثالي لتخطيطات الصفحة المعقدة والـ Layout الرئيسي.

3. قسم Tailwind CSS (إطار عمل Utility-First)

الأسئلة مرتبة من الأساسي إلى المتقدم.

Q1: كيف تتعامل Tailwind مع الاستجابة (Responsiveness)؟

الإجابة: تستخدم بادئات نقاط التوقف التي تعتمد على "موبايل أولاً" (mobile-first) مثل sm:، md:، و lg:. الفئات التي لا تحتوي على بادئة تنطبق على جميع الأحجام، بينما البادئات تقوم بتجاوزها من نقطة التوقف تلك فما فوق.

Q2: ما هي البادئات (Variants) الأكثر شيوعاً التي تستخدمها Tailwind؟

الإجابة: تستخدم Tailwind البادئات لتطبيق الأنماط بناءً على حالة العنصر أو نقطة التوقف.

Responsive: مثل sm: و lg:، لتطبيق الأنماط في نقاط توقف محددة.

State: مثل hover:، focus:، و active:، وتطبق الأنماط عند تفاعل المستخدم مع العنصر.

Q3: كيف يمكنك تخصيص Tailwind؟

الإجابة: عن طريق تحرير ملف tailwind.config.js. يمكنك توسيع النمط (extend the theme) لإضافة ألوان، خطوط، أو مسافات جديدة مع الحفاظ على القيم الافتراضية، أو تجاوز الإعدادات الافتراضية بالكامل.

Q4: ما هو وضع JIT (Just-In-Time) في Tailwind ولماذا هو مهم؟

الإجابة: JIT هو محرك التجميع الذي يسمح بإنشاء فئات الأدوات المساعدة ديناميكياً عند الحاجة أثناء التطوير. هذا يعني أن التجميع أسرع بكثير، ويتيح استخدام قيم عشوائية (مثل top-[13px]) مباشرةً.

Q5: كيف تعمل Tailwind على التحسين للإنتاج (Production)؟

الإجابة: تستخدم عملية Purging أو Tree-Shaking. هذه العملية تقوم بمسح ملفات القوالب (HTML، JS) وتزيل جميع فئات Tailwind غير المستخدمة من ملف CSS المجمّع النهائي، مما يقلل حجم الملف إلى أدنى حد ممكن.

4. قسم JavaScript (منطق الويب)

الأسئلة مرتبة من الأساسي إلى المتقدم.

Q1: == مقابل ===؟

الإجابة:

== (Loose Equality): يتحقق من القيمة بعد إجراء تحويل النوع (type coercion).

=== (Strict Equality): يتحقق من كل من القيمة والنوع دون تحويل. يفضل دائماً استخدام === لتجنب الأخطاء.

Q2: var مقابل let مقابل const؟

الإجابة:

var: يقتصر على نطاق الدالة (function-scoped) (قديم).

let: يقتصر على نطاق الكتلة (block-scoped) ({ }) ويمكن إعادة تعيينه.

const: يقتصر على نطاق الكتلة ولا يمكن إعادة تعيينه (إنه مرجع ثابت).

Q3: ما هي الكلمة المفتاحية this؟

الإجابة: كلمة مفتاحية تشير إلى السياق الذي يتم فيه تنفيذ الدالة. تتغير قيمتها بناءً على كيفية استدعاء الدالة. في Arrow Functions، يتم تحديد قيمة this بشكل معجمي (lexically) من النطاق المحيط.

Q4: ما هو Closure؟

الإجابة: هي قدرة الدالة على "تذكر" والوصول إلى المتغيرات من النطاق الخارجي (المحيط) لها، حتى بعد انتهاء تنفيذ هذا النطاق. تُستخدم لإنشاء متغيرات خاصة (private variables) والاحتفاظ بالحالة.

Q5: اشرح Promises و Async/Await.

الإجابة:

Promise: كائن يمثل الإكمال النهائي (أو الفشل) لعملية غير متزامنة (asynchronous).

Async/Await: هي صياغة مبسطة (Syntactic sugar) مبنية فوق الـ Promises. تجعل الكود غير المتزامن يبدو متزامناً وأسهل في القراءة.

5. قسم React (مكتبة الواجهة الرسومية)

الأسئلة مرتبة من الأساسي إلى المتقدم.

Q1: Props مقابل State؟

الإجابة:

Props: يتم تمريرها إلى المكون من المكون الأصل وهي غير قابلة للتغيير (للقراءة فقط).

State: تتم إدارتها داخل المكون ويمكن أن تتغير بمرور الوقت، مما يؤدي إلى إعادة عرض (re-render) المكون.

Q2: ما هو Virtual DOM؟

الإجابة: تمثيل خفيف الوزن موجود في الذاكرة لـ DOM المتصفح "الحقيقي". يقوم React بـ "diffing" (المقارنة) بين الـ VDOM الجديد والقديم، ويحسب الحد الأدنى من التغييرات اللازمة لتحديث DOM الحقيقي بكفاءة.

Q3: useState مقابل useEffect؟

الإجابة:

useState: هو Hook لإضافة متغيرات الحالة (state variables) إلى المكونات الوظيفية.

useEffect: هو Hook لتنفيذ "تأثيرات جانبية" (side effects) (مثل جلب البيانات) بعد عرض المكون.

Q4: ما هي مشكلة Prop Drilling؟

الإجابة: هي عملية تمرير البيانات عبر العديد من المكونات المتداخلة التي لا تحتاج إلى تلك البيانات نفسها، فقط للوصول إلى مكون متعمق يحتاجها. يتم حلها باستخدام Context API أو مكتبة إدارة الحالة.

Q5: ما هي الـ Custom Hooks (الخطافات المخصصة)؟

الإجابة: هي ببساطة دوال JavaScript يبدأ اسمها بـ use (مثل useFetch). تسمح لك باستخراج منطق الحالة (stateful logic) من المكون بحيث يمكن إعادة استخدامه بسهولة في مكونات أخرى، مما يحافظ على نظافة المكونات ويمنع تكرار الكود.
